<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Carbon;
use App\Models\CertificadoFIC;
use App\Models\Empresa;
use Illuminate\Support\Facades\Log;
use Barryvdh\DomPDF\Facade\Pdf;

class WhatsAppController extends Controller
{
    // Verificar el webhook (requerido por Meta)
    public function verifyWebhook(Request $request)
    {
        Log::info('ğŸ” === WHATSAPP WEBHOOK VERIFICATION STARTED ===');
        Log::info('Query parameters:', $request->query());

        // Meta typically sends hub.mode, hub.verify_token, hub.challenge
        $mode = $request->query('hub.mode');
        $token = $request->query('hub.verify_token');
        $challenge = $request->query('hub.challenge');

        // SOLUCIÃ“N DEFINITIVA - Token hardcodeado (mejor si lo pones en env en producciÃ³n)
        $expectedToken = env('WHATSAPP_VERIFY_TOKEN', 'chatbotwhatsapp');

        // Verificar parÃ¡metros requeridos
        if (empty($mode) || empty($token) || empty($challenge)) {
            Log::error('âŒ Faltan parÃ¡metros requeridos en verificaciÃ³n de webhook', $request->query());
            return response('Bad Request - Missing parameters', 400);
        }

        // Verificar el modo
        if ($mode !== 'subscribe') {
            Log::warning("âŒ Modo incorrecto. Esperado: 'subscribe', Recibido: '{$mode}'");
            return response('Forbidden - Invalid mode', 403);
        }

        // VerificaciÃ³n case-insensitive
        $normalizedReceived = strtolower(trim($token));
        $normalizedExpected = strtolower(trim($expectedToken));

        Log::info("ğŸ” COMPARACIÃ“N NORMALIZADA - Recibido: '{$normalizedReceived}', Esperado: '{$normalizedExpected}'");

        if ($normalizedReceived === $normalizedExpected) {
            Log::info('âœ… WEBHOOK VERIFICADO EXITOSAMENTE!');
            Log::info("ğŸ“¤ Devolviendo challenge: {$challenge}");
            return response($challenge, 200)
                ->header('Content-Type', 'text/plain');
        }

        Log::warning('âŒ Token de verificaciÃ³n incorrecto');
        return response('Forbidden - Token mismatch', 403);
    }

    // Recibir mensajes de WhatsApp (mejorado: plantilla si primera vez o >24h)
    public function webhook(Request $request)
    {
        Log::info('=== WEBHOOK INICIADO ===');
        Log::info('Headers:', $request->headers->all());
        
        // ğŸ”¥ CAMBIO CRÃTICO: Obtener el contenido RAW del request
        $rawBody = $request->getContent();
        Log::info('ğŸ“¨ Raw body recibido: ' . $rawBody);
        
        // Intentar decodificar el JSON manualmente
        $data = json_decode($rawBody, true);
        
        // Si hay error en el JSON, loguear y salir
        if (json_last_error() !== JSON_ERROR_NONE) {
            Log::error('âŒ Error decodificando JSON: ' . json_last_error_msg());
            Log::info('=== WEBHOOK FINALIZADO (ERROR JSON) ===');
            return response('Error en JSON', 400);
        }
        
        // Si json_decode fallÃ³, intentar con $request->all()
        if (empty($data)) {
            Log::warning('âš ï¸ JSON decode vacÃ­o, intentando con $request->all()');
            $data = $request->all();
        }
        
        Log::info('Webhook data recibida:', $data);

        // Verificar que es un mensaje vÃ¡lido (mÃºltiples estructuras posibles)
        $message = null;
        $userPhone = null;
        $messageText = null;
        
        // Estructura 1: La que espera tu cÃ³digo original
        if (isset($data['entry'][0]['changes'][0]['value']['messages'][0])) {
            $message = $data['entry'][0]['changes'][0]['value']['messages'][0];
            Log::info('âœ… Mensaje encontrado en estructura estÃ¡ndar');
        }
        // Estructura 2: Alternativa que podrÃ­a venir de Meta
        elseif (isset($data['entry'][0]['changes'][0]['value']['message'])) {
            $message = $data['entry'][0]['changes'][0]['value']['message'];
            Log::info('âœ… Mensaje encontrado en estructura alternativa (message)');
        }
        // Estructura 3: Otra variante comÃºn
        elseif (isset($data['entry'][0]['messaging'][0]['message'])) {
            $message = $data['entry'][0]['messaging'][0]['message'];
            Log::info('âœ… Mensaje encontrado en estructura messaging');
        }

        if ($message) {
            $rawFrom = $message['from'] ?? '';
            $normalizedPhone = preg_replace('/\D+/', '', $rawFrom);
            $userPhone = $normalizedPhone;
            $messageText = $message['text']['body'] ?? ($message['body'] ?? '');

            Log::info("ğŸ“± Mensaje recibido - De: {$userPhone}, Texto: {$messageText}");
            Log::info("ğŸ“‹ Detalles del mensaje:", $message);

            // Solo procesar si tenemos un nÃºmero y mensaje vÃ¡lidos
            if (!empty($userPhone) && !empty($messageText)) {
                // Registrar recepciÃ³n: actualizamos last interaction en recepciÃ³n
                $this->setLastInteraction($userPhone, now());

                // Si es la primera vez o pasaron >=24 horas, enviar plantilla (Utility) antes de procesar
                $last = $this->getLastInteraction($userPhone);
                $needTemplate = false;
                if (!$last) {
                    $needTemplate = true;
                } else {
                    $hours = Carbon::now()->diffInHours($last);
                    if ($hours >= 24) $needTemplate = true;
                }

                $sentTemplate = false;
                if ($needTemplate) {
                    Log::info("ğŸ”” Enviando plantilla de bienvenida (first/timeout) a {$userPhone}");
                    if ($this->sendTemplate($userPhone, 'welcome_menu')) {
                        $sentTemplate = true;
                    }
                }

                // Procesar el mensaje â€” si enviamos plantilla, suprimir el envÃ­o de bienvenida duplicada
                $this->processMessage($userPhone, $messageText, $sentTemplate);
            } else {
                Log::warning('âŒ NÃºmero de telÃ©fono o mensaje vacÃ­o');
            }

        } else {
            Log::warning('âŒ No se encontrÃ³ mensaje en el webhook');
            Log::info('Estructura completa recibida:', $data);
            
            // Debug: mostrar las claves disponibles para diagnÃ³stico
            Log::info('ğŸ” Claves disponibles en data:', array_keys($data));
            if (isset($data['entry'][0])) {
                Log::info('ğŸ” Estructura de entry[0]:', $data['entry'][0]);
            }
        }

        Log::info('=== WEBHOOK FINALIZADO ===');
        return response('Mensaje recibido', 200);
    }

    /**
     * Procesa mensajes entrantes y controla flujos.
     * El tercer parÃ¡metro ($suppressWelcome) evita reenviar el menÃº si ya se enviÃ³ la plantilla.
     */
    private function processMessage($userPhone, $messageText, $suppressWelcome = false)
    {
        Log::info("=== PROCESS MESSAGE INICIADO ===");
        Log::info("Procesando mensaje - Usuario: {$userPhone}, Texto: {$messageText}");

        $testNumbers = [
            '16315551181',
            '16505551111',
        ];

        if (in_array($userPhone, $testNumbers)) {
            Log::info("ğŸ”§ Ignorando mensaje de prueba de Meta: {$userPhone}");
            return;
        }

        $raw = trim($messageText);
        $messageLower = strtolower($raw);

        $userState = $this->getUserState($userPhone);
        Log::info("Estado actual del usuario:", $userState);

        // Auth flow
        $authSteps = [
            'awaiting_username',
            'awaiting_password'
        ];
        if (!empty($userState['step']) && in_array($userState['step'], $authSteps)) {
            Log::info("Estado de autenticaciÃ³n detectado ({$userState['step']}) â€” manejando por flujo de auth");
            $this->handleAuthFlow($userPhone, $messageText, $userState);
            Log::info("=== PROCESS MESSAGE FINALIZADO (por auth flow) ===");
            return;
        }

        // Certificate flow
        $certificateSteps = [
            'choosing_certificate_type',
            'awaiting_nit_ticket',
            'awaiting_ticket',
            'awaiting_nit_general',
            'awaiting_nit_vigencia',
            'awaiting_year'
        ];
        if (!empty($userState['step']) && in_array($userState['step'], $certificateSteps)) {
            Log::info("Estado activo detectado ({$userState['step']}) â€” manejando por flujo de certificado");
            $this->handleCertificateFlow($userPhone, $messageLower, $userState);
            Log::info("=== PROCESS MESSAGE FINALIZADO (por flujo activo) ===");
            return;
        }

        // Handlers generales (modificado para soportar suppressWelcome)
        if (str_contains($messageLower, 'hola') || $messageLower === 'inicio' || $messageLower === 'menu') {
            Log::info("ğŸ¤– Enviando mensaje de bienvenida (conditional) - suppressWelcome={$suppressWelcome}");
            if (! $suppressWelcome) {
                $this->sendWelcomeMessage($userPhone);
            } else {
                Log::info("ğŸ¤– Omitido envÃ­o de mensaje de bienvenida porque ya se enviÃ³ la plantilla");
            }
            $this->updateUserState($userPhone, ['step' => 'main_menu']);
            return;
        }

        if (str_contains($messageLower, 'generar certificado') || $messageLower === 'generar' || str_contains($messageLower, 'certificado')) {
            Log::info("ğŸ¤– Usuario solicitÃ³ iniciar flujo de Generar Certificado");
            $this->startAuthentication($userPhone);
            return;
        }

        if (str_contains($messageLower, 'requisitos')) {
            Log::info("ğŸ¤– Usuario solicitÃ³ Requisitos");
            $this->sendRequirements($userPhone);
            return;
        }

        if (str_contains($messageLower, 'soporte') || str_contains($messageLower, 'ayuda') || str_contains($messageLower, 'contacto')) {
            Log::info("ğŸ¤– Usuario solicitÃ³ Soporte");
            $this->sendSupportInfo($userPhone);
            return;
        }

        if (str_contains($messageLower, 'registro') || str_contains($messageLower, 'registrarse')) {
            Log::info("ğŸ¤– Usuario solicitÃ³ informaciÃ³n de registro");
            $this->sendRegistrationInfo($userPhone);
            return;
        }

        Log::info("â“ No se reconociÃ³ comando global, enviando ayuda corta");
        $this->sendMessage($userPhone, "No entendÃ­ ğŸ¤”. Puedes escribir: *Generar Certificado*, *Requisitos*, *Soporte* o *Registro*.");
        Log::info("=== PROCESS MESSAGE FINALIZADO ===");
    }

    /**
     * Manejar flujo de autenticaciÃ³n
     */
    private function handleAuthFlow($userPhone, $messageText, $userState)
    {
        Log::info("=== HANDLE AUTH FLOW INICIADO ===");
        Log::info("Paso actual: " . ($userState['step'] ?? 'none'));
        Log::info("Mensaje: {$messageText}");

        $step = $userState['step'] ?? '';

        switch ($step) {
            case 'awaiting_username':
                Log::info("ğŸ‘¤ Usuario ingresando username: {$messageText}");
                $this->processUsername($userPhone, $messageText);
                break;

            case 'awaiting_password':
                Log::info("ğŸ” Usuario ingresando password");
                $this->processPassword($userPhone, $messageText);
                break;

            default:
                Log::info("ğŸ”€ Estado de auth no reconocido, reiniciando");
                $this->startAuthentication($userPhone);
                break;
        }

        Log::info("=== HANDLE AUTH FLOW FINALIZADO ===");
    }

    /**
     * Iniciar proceso de autenticaciÃ³n
     */
    private function startAuthentication($userPhone)
    {
        Log::info("ğŸ” Iniciando autenticaciÃ³n para usuario: {$userPhone}");

        $message = "ğŸ” *VALIDACIÃ“N DE USUARIO*\n\n";
        $message .= "âš ï¸ *Debes validar tu informaciÃ³n antes de generar un certificado.*\n\n";
        $message .= "Por favor, ingresa tu *USUARIO*:";

        $this->sendMessage($userPhone, $message);
        $this->updateUserState($userPhone, ['step' => 'awaiting_username']);
    }

    /**
     * Procesar nombre de usuario
     */
    private function processUsername($userPhone, $username)
    {
        Log::info("ğŸ” Buscando usuario en BD: {$username}");

        $empresa = Empresa::buscarPorUsuario($username);

        if (!$empresa) {
            Log::warning("âŒ Usuario no encontrado: {$username}");
            $message = "âŒ *USUARIO NO REGISTRADO*\n\n";
            $message .= "No tienes usuario registrado con nosotros.\n\n";
            $message .= "Por favor, *regÃ­strate* y vuelve aquÃ­!\n\n";
            $message .= "Escribe *REGISTRO* para ver informaciÃ³n de registro o *MENU* para volver al inicio.";

            $this->sendMessage($userPhone, $message);
            $this->clearUserState($userPhone);
            return;
        }

        Log::info("âœ… Usuario encontrado: " . $empresa->representante_legal);

        $message = "âœ… Usuario encontrado.\n\n";
        $message .= "ğŸ‘¤ *" . $empresa->representante_legal . "*\n\n";
        $message .= "Ahora ingresa tu *CONTRASEÃ‘A*:";

        $this->sendMessage($userPhone, $message);
        $this->updateUserState($userPhone, [
            'step' => 'awaiting_password',
            'username' => $username,
            'empresa_id' => $empresa->id,
            'nit' => $empresa->nit
        ]);
    }

    /**
     * Procesar contraseÃ±a
     */
    private function processPassword($userPhone, $password)
    {
        $userState = $this->getUserState($userPhone);
        $username = $userState['username'] ?? null;

        if (!$username) {
            Log::error("âŒ No se encontrÃ³ username en el estado");
            $this->sendMessage($userPhone, "âŒ Error en la autenticaciÃ³n. Por favor, inicia nuevamente.");
            $this->clearUserState($userPhone);
            return;
        }

        Log::info("ğŸ” Validando contraseÃ±a para usuario: {$username}");

        $empresa = Empresa::buscarPorUsuario($username);

        if (!$empresa) {
            Log::error("âŒ Empresa no encontrada para usuario: {$username}");
            $this->sendMessage($userPhone, "âŒ Error en la autenticaciÃ³n. Por favor, inicia nuevamente.");
            $this->clearUserState($userPhone);
            return;
        }

        if (!$empresa->verificarContraseÃ±a($password)) {
            Log::warning("âŒ ContraseÃ±a incorrecta para usuario: {$username}");
            $message = "âŒ *CONTRASEÃ‘A INCORRECTA*\n\n";
            $message .= "La contraseÃ±a ingresada no es correcta.\n\n";
            $message .= "Por favor, vuelve a ingresar tu *USUARIO* o escribe *MENU* para volver al inicio.";

            $this->sendMessage($userPhone, $message);
            $this->updateUserState($userPhone, [
                'step' => 'awaiting_username',
                'username' => null
            ]);
            return;
        }

        Log::info("âœ… AutenticaciÃ³n exitosa para: " . $empresa->representante_legal);

        $message = "âœ… *AUTENTICACIÃ“N EXITOSA*\n\n";
        $message .= "Bienvenido *{$empresa->representante_legal}*\n";
        $message .= "ğŸ“„ NIT: *{$empresa->nit}*\n\n";
        $message .= "Ahora puedes generar tu certificado.\n\n";

        $this->sendMessage($userPhone, $message);

        $this->sendCertificateOptions($userPhone);
        $this->updateUserState($userPhone, [
            'step' => 'choosing_certificate_type',
            'authenticated' => true,
            'empresa_nit' => $empresa->nit,
            'representante_legal' => $empresa->representante_legal
        ]);
    }

    private function handleCertificateFlow($userPhone, $messageText, $userState)
    {
        Log::info("=== HANDLE CERTIFICATE FLOW INICIADO ===");
        Log::info("Paso actual: " . ($userState['step'] ?? 'none'));
        Log::info("Mensaje: {$messageText}");

        $step = $userState['step'] ?? '';

        if (!isset($userState['authenticated']) || !$userState['authenticated']) {
            Log::warning("âŒ Usuario no autenticado intentando generar certificado");
            $this->sendMessage($userPhone, "âŒ Debes autenticarte primero para generar certificados.");
            $this->startAuthentication($userPhone);
            return;
        }

        $nit = $userState['empresa_nit'] ?? null;
        if (!$nit) {
            Log::error("âŒ No se encontrÃ³ NIT en el estado del usuario autenticado");
            $this->sendMessage($userPhone, "âŒ Error: No se encontrÃ³ informaciÃ³n de la empresa. Por favor, autentÃ­cate nuevamente.");
            $this->startAuthentication($userPhone);
            return;
        }

        switch ($step) {
            case 'choosing_certificate_type':
                Log::info("ğŸ”€ Usuario eligiendo tipo de certificado (por texto)");
                if (str_contains($messageText, 'ticket')) {
                    Log::info("ğŸ« Usuario seleccionÃ³ Ticket");
                    $this->updateUserState($userPhone, [
                        'step' => 'awaiting_ticket',
                        'type' => 'ticket'
                    ]);
                    $this->sendMessage($userPhone, "ğŸ« *Certificado por TICKET*\n\nPor favor ingresa el nÃºmero de *TICKET*:");
                } elseif (str_contains($messageText, 'nit') && !str_contains($messageText, 'vigencia')) {
                    Log::info("ğŸ¢ Usuario seleccionÃ³ NIT - Generando certificado general");
                    $this->generateAndSendCertificate($userPhone, 'nit_general', [
                        'nit' => $nit
                    ]);
                } elseif (str_contains($messageText, 'vigencia') || str_contains($messageText, 'vigente')) {
                    Log::info("ğŸ“… Usuario seleccionÃ³ Vigencia");
                    $this->updateUserState($userPhone, [
                        'step' => 'awaiting_year',
                        'type' => 'vigencia'
                    ]);
                    $this->sendMessage($userPhone, "ğŸ“… *Certificado por VIGENCIA*\n\nIngresa el *AÃ‘O* de la vigencia (ejemplo: 2025). Solo se permiten 15 aÃ±os atrÃ¡s desde el actual.");
                } else {
                    Log::info("âŒ OpciÃ³n no reconocida en choosing_certificate_type, reenviando instrucciones");
                    $this->sendMessage($userPhone, "No reconocÃ­ la opciÃ³n. Responde con *TICKET*, *NIT* o *VIGENCIA* segÃºn corresponda.");
                }
                break;

            case 'awaiting_ticket':
                Log::info("ğŸŸï¸ Usuario ingresando ticket: {$messageText}");
                $this->generateAndSendCertificate($userPhone, 'nit_ticket', [
                    'nit' => $nit,
                    'ticket' => $messageText
                ]);
                break;

            case 'awaiting_year':
                Log::info("ğŸ“… Usuario ingresando aÃ±o: {$messageText}");
                $year = intval(preg_replace('/[^0-9]/','',$messageText));
                $currentYear = date('Y');

                if ($year <= 0 || $year > $currentYear || $year < ($currentYear - 15)) {
                    Log::warning("âŒ AÃ±o fuera de rango: {$year}");
                    $this->sendMessage($userPhone, "âŒ *AÃ±o fuera de rango*\n\nSolo se permiten vigencias entre " . ($currentYear - 15) . " y $currentYear . Por favor ingresa un aÃ±o vÃ¡lido (ej: 2025).");
                    return;
                }

                $this->generateAndSendCertificate($userPhone, 'nit_vigencia', [
                    'nit' => $nit,
                    'vigencia' => $year
                ]);
                break;

            default:
                Log::info("ğŸ”€ Estado no reconocido, enviando mensaje de bienvenida");
                $this->sendWelcomeMessage($userPhone);
                break;
        }

        Log::info("=== HANDLE CERTIFICATE FLOW FINALIZADO ===");
    }

    private function generateAndSendCertificate($userPhone, $type, $data)
    {
        Log::info("=== GENERATE AND SEND CERTIFICATE INICIADO ===");
        Log::info("Tipo: {$type}, Datos:", $data);

        try {
            $this->sendMessage($userPhone, "â³ *Generando certificado...*\n\nPor favor espera unos segundos.");

            $certificados = $this->buscarCertificados($type, $data['nit'], $data['ticket'] ?? null, $data['vigencia'] ?? null);
            Log::info("Certificados encontrados: " . $certificados->count());

            if ($certificados->isEmpty()) {
                Log::warning("âŒ No se encontraron certificados para los criterios");
                $this->sendMessage($userPhone, "âŒ *No se encontraron certificados*\n\nNo hay certificados con los criterios especificados.");
                $this->clearUserState($userPhone);
                return;
            }

            Log::info("ğŸ“„ Generando PDF...");
            $pdfPath = $this->generarPdf($certificados, $type);
            Log::info("PDF generado en: {$pdfPath}");

            Log::info("ğŸ“¤ Enviando documento por WhatsApp...");
            $this->sendDocument($userPhone, $pdfPath, $this->generarNombreArchivo($certificados->first(), $type));

            $this->sendMessage($userPhone, "âœ… *Certificado generado exitosamente!*\n\nTu certificado FIC ha sido generado y enviado.");
            $this->sendMessage($userPhone, "Â¿Necesitas algo mÃ¡s? Escribe *MENU* para ver las opciones.");

            $userState = $this->getUserState($userPhone);
            $this->updateUserState($userPhone, [
                'step' => 'main_menu',
                'authenticated' => true,
                'empresa_nit' => $userState['empresa_nit'] ?? null,
                'representante_legal' => $userState['representante_legal'] ?? null
            ]);

        } catch (\Exception $e) {
            Log::error('âŒ Error generando certificado WhatsApp: ' . $e->getMessage());
            Log::error('Stack trace: ' . $e->getTraceAsString());
            $this->sendMessage($userPhone, "âŒ *Error del sistema*\n\nPor favor intenta nuevamente o contacta a soporte.");
            $this->clearUserState($userPhone);
        }

        Log::info("=== GENERATE AND SEND CERTIFICATE FINALIZADO ===");
    }

    // MÃ©todos auxiliares existentes
    private function buscarCertificados($tipo, $nit, $ticket = null, $vigencia = null)
    {
        Log::info("ğŸ” Buscando certificados - Tipo: {$tipo}, NIT: {$nit}, Ticket: {$ticket}, Vigencia: {$vigencia}");

        $query = CertificadoFIC::where('constructor_nit', $nit);
        Log::info("Query base construida, count: " . $query->count());

        switch ($tipo) {
            case 'nit_ticket':
                $result = $query->where('ticket', $ticket)->get();
                Log::info("Resultado busqueda por ticket: " . $result->count());
                return $result;
            case 'nit_vigencia':
                $pattern = $vigencia . '-%';
                $result = $query->where('periodo', 'like', $pattern)->get();
                Log::info("Resultado busqueda por vigencia {$pattern}: " . $result->count());
                return $result;
            case 'nit_general':
            default:
                $result = $query->get();
                Log::info("Resultado busqueda general: " . $result->count());
                return $result;
        }
    }

    private function generarPdf($certificados, $tipo)
    {
        Log::info("ğŸ“Š Generando PDF para {$certificados->count()} certificados, tipo: {$tipo}");

        $constructor = $certificados->first();
        $total = $certificados->sum('valor_pago');

        Log::info("Constructor: {$constructor->constructor_razon_social}, Total: {$total}");

        $datos = [
            'certificados' => $certificados,
            'constructor' => $constructor,
            'total' => $total,
            'fecha_emision' => now(),
            'tipo_busqueda' => $tipo
        ];

        $pdf = Pdf::loadView('certificados.plantilla', $datos)
                  ->setPaper('a4', 'portrait')
                  ->setOptions([
                      'defaultFont' => 'Arial',
                      'isHtml5ParserEnabled' => true,
                      'isRemoteEnabled' => true
                  ]);

        $fileName = $this->generarNombreArchivo($constructor, $tipo);
        $filePath = storage_path('app/temp/' . $fileName);

        Log::info("Guardando PDF en: {$filePath}");

        if (!file_exists(dirname($filePath))) {
            Log::info("Creando directorio: " . dirname($filePath));
            mkdir(dirname($filePath), 0755, true);
        }

        $pdf->save($filePath);
        Log::info("âœ… PDF guardado exitosamente");

        return $filePath;
    }

    private function generarNombreArchivo($constructor, $tipo)
    {
        $fecha = now()->format('Y-m-d');
        $nit = $constructor->constructor_nit;
        $fileName = "Certificado_FIC_{$nit}_{$tipo}_{$fecha}.pdf";
        Log::info("Nombre de archivo generado: {$fileName}");
        return $fileName;
    }

    // Mensajes predefinidos
    private function sendWelcomeMessage($userPhone)
    {
        Log::info("ğŸ‘‹ Enviando mensaje de bienvenida corto a {$userPhone}");
        $message = "Hola ğŸ‘‹, gracias por escribir al Chatbot FIC - SENA.\n\n";
        $message .= "Este asistente te ayuda a: obtener certificados, consultar requisitos y solicitar soporte tÃ©cnico.\n\n";
        $message .= "Escribe lo que necesitas o escribe \"*MENU*\" para ver las opciones.";

        $this->sendMessage($userPhone, $message);
    }

    private function sendCertificateOptions($userPhone)
    {
        Log::info("ğŸ“„ Enviando opciones de certificado a {$userPhone}");
        $message = "ğŸ“„ *GENERAR CERTIFICADO FIC*\n\n";
        $message .= "Por favor indica el *tipo* de certificado escribiendo su nombre:\n\n";
        $message .= "â€¢ *TICKET* - Certificado especÃ­fico por nÃºmero de ticket\n";
        $message .= "â€¢ *NIT* - Todos los certificados asociados a tu NIT\n";
        $message .= "â€¢ *VIGENCIA* - Certificado filtrado por aÃ±o de vigencia\n\n";
        $message .= "Ejemplo: responde *NIT* para buscar todos tus certificados.";

        $this->sendMessage($userPhone, $message);
    }

    private function sendRequirements($userPhone)
    {
        Log::info("ğŸ“‹ Enviando requisitos a {$userPhone}");
        $message = "ğŸ“‹ *REQUISITOS PARA CERTIFICADOS FIC*\n\n";
        $message .= "â€¢ NIT o CÃ©dula del empresario\n";
        $message .= "â€¢ Tipo de certificado (Ticket, NIT o Vigencia)\n";
        $message .= "â€¢ Para vigencia: aÃ±o especÃ­fico (mÃ¡x. 15 aÃ±os atrÃ¡s)\n\n";
        $message .= "Escribe *MENU* para volver al inicio.";

        $this->sendMessage($userPhone, $message);
    }

    private function sendSupportInfo($userPhone)
    {
        Log::info("ğŸ“ Enviando info de soporte a {$userPhone}");
        $message = "ğŸ“ *SOPORTE TÃ‰CNICO*\n\n";
        $message .= "Para asistencia tÃ©cnica contacta:\n\n";
        $message .= "ğŸ“§ Email: soporte@sena.edu.co\n";
        $message .= "ğŸŒ Web: www.sena.edu.co\n\n";
        $message .= "Escribe *MENU* para volver al inicio.";

        $this->sendMessage($userPhone, $message);
    }

    private function sendRegistrationInfo($userPhone)
    {
        Log::info("ğŸ“ Enviando info de registro a {$userPhone}");
        $message = "ğŸ“ *REGISTRO DE NUEVO USUARIO*\n\n";
        $message .= "Para registrarte en nuestro sistema, debes ir a la pagina de oficial:\n\n";
        $message .= "ğŸŒ *Web:* www.fic.sena.edu.co/registro\n\n";
        $message .= "Escribe *MENU* para volver al inicio.";

        $this->sendMessage($userPhone, $message);
    }

    // MÃ©todos para enviar mensajes y documentos
    private function sendMessage($to, $message)
    {
        Log::info("âœ‰ï¸ ENVIANDO MENSAJE - Para: {$to}");
        Log::info("ğŸ“ Mensaje: {$message}");

        $phoneNumberId = config('services.whatsapp.phone_number_id');
        $accessToken = config('services.whatsapp.access_token');

        if (empty($phoneNumberId) || empty($accessToken)) {
            Log::error('âŒ ConfiguraciÃ³n de WhatsApp incompleta. Revisa services.whatsapp.phone_number_id y access_token');
            return;
        }

        $url = 'https://graph.facebook.com/v24.0/' . $phoneNumberId . '/messages';
        Log::info("ğŸŒ URL: {$url}");
        Log::info("ğŸ”‘ Token (partial): " . (is_string($accessToken) ? substr($accessToken, 0, 10) . "..." : 'n/a'));
        Log::info("ğŸ“ Phone Number ID: " . $phoneNumberId);

        try {
            $response = Http::withToken($accessToken)
                ->timeout(30)
                ->post($url, [
                    'messaging_product' => 'whatsapp',
                    'to' => $to,
                    'text' => ['body' => $message]
                ]);

            Log::info("ğŸ“¡ Respuesta HTTP Status: " . $response->status());
            Log::info("ğŸ“¡ Respuesta WhatsApp API:", $response->json());

            if ($response->successful()) {
                Log::info("âœ… Mensaje enviado exitosamente a {$to}");
                // marcar Ãºltima interacciÃ³n outbound
                $this->setLastInteraction($to, now());

                // Guardar outbound en BD si devuelve message id
                $respJson = $response->json();
                $outMsgId = $respJson['messages'][0]['id'] ?? null;
                try {
                    if (class_exists(WhatsappMessage::class)) {
                        WhatsappMessage::create([
                            'message_id' => $outMsgId,
                            'from_number' => $phoneNumberId,
                            'to_phone_number_id' => $to,
                            'direction' => 'outbound',
                            'message' => $message,
                            'payload' => json_encode($respJson)
                        ]);
                    }
                } catch (\Throwable $e) {
                    Log::warning('No se pudo guardar outbound en BD: ' . $e->getMessage());
                }
            } else {
                Log::error("âŒ Error enviando mensaje: " . $response->body());
            }

        } catch (\Exception $e) {
            Log::error("ğŸ’¥ ExcepciÃ³n enviando mensaje: " . $e->getMessage());
            Log::error("ğŸ“‹ Stack trace: " . $e->getTraceAsString());
        }
    }

    private function sendDocument($to, $filePath, $fileName)
    {
        Log::info("ğŸ“ ENVIANDO DOCUMENTO - Para: {$to}, Archivo: {$fileName}");
        Log::info("ğŸ“ Ruta del archivo: {$filePath}");

        $phoneNumberId = config('services.whatsapp.phone_number_id');
        $accessToken = config('services.whatsapp.access_token');

        if (empty($phoneNumberId) || empty($accessToken)) {
            Log::error('âŒ ConfiguraciÃ³n de WhatsApp incompleta. Revisa services.whatsapp.phone_number_id y access_token');
            return;
        }

        $url = 'https://graph.facebook.com/v17.0/' . $phoneNumberId . '/messages';

        try {
            Log::info("â¬†ï¸ Subiendo archivo a WhatsApp...");
            $mediaResponse = Http::withToken($accessToken)
                ->attach('file', file_get_contents($filePath), $fileName)
                ->post('https://graph.facebook.com/v17.0/' . $phoneNumberId . '/media', [
                    'messaging_product' => 'whatsapp',
                    'type' => 'document/pdf'
                ]);

            Log::info("ğŸ“¡ Respuesta subida de archivo:", $mediaResponse->json());

            if (isset($mediaResponse->json()['id'])) {
                $mediaId = $mediaResponse->json()['id'];
                Log::info("ğŸ†” Media ID obtenido: {$mediaId}");

                Log::info("ğŸ“¤ Enviando documento con media ID...");
                $sendResponse = Http::withToken($accessToken)
                    ->post($url, [
                        'messaging_product' => 'whatsapp',
                        'to' => $to,
                        'type' => 'document',
                        'document' => [
                            'id' => $mediaId,
                            'filename' => $fileName
                        ]
                    ]);

                Log::info("ğŸ“¡ Respuesta envÃ­o de documento:", $sendResponse->json());
                if ($sendResponse->successful()) {
                    Log::info("âœ… Documento enviado exitosamente");
                    // marcar Ãºltima interacciÃ³n outbound
                    $this->setLastInteraction($to, now());

                    $respJson = $sendResponse->json();
                    try {
                        if (class_exists(WhatsappMessage::class)) {
                            WhatsappMessage::create([
                                'message_id' => $respJson['messages'][0]['id'] ?? null,
                                'from_number' => $phoneNumberId,
                                'to_phone_number_id' => $to,
                                'direction' => 'outbound',
                                'message' => '[document] ' . $fileName,
                                'payload' => json_encode($respJson)
                            ]);
                        }
                    } catch (\Throwable $e) {
                        Log::warning('No se pudo guardar outbound (document): ' . $e->getMessage());
                    }
                } else {
                    Log::error("âŒ Error al enviar documento: " . $sendResponse->body());
                }
            } else {
                Log::error("âŒ No se pudo obtener media ID");
            }

        } catch (\Exception $e) {
            Log::error("ğŸ’¥ ExcepciÃ³n enviando documento: " . $e->getMessage());
            Log::error("ğŸ“‹ Stack trace: " . $e->getTraceAsString());
        }

        if (file_exists($filePath)) {
            unlink($filePath);
            Log::info("ğŸ§¹ Archivo temporal eliminado: {$filePath}");
        }
    }

    // -------------------- helpers para interacciÃ³n --------------------
    private function getLastInteraction($userPhone)
    {
        $key = "wh_last_interaction_{$userPhone}";
        $val = Cache::get($key);
        if ($val) return Carbon::parse($val);
        return null;
    }

    private function setLastInteraction($userPhone, $time)
    {
        $key = "wh_last_interaction_{$userPhone}";
        Cache::put($key, Carbon::parse($time)->toISOString(), now()->addDays(30));
    }

    /**
     * EnvÃ­a una plantilla (template) usando WhatsApp Cloud API.
     * Retorna true si el envÃ­o fue exitoso (status 200/2xx).
     */
    private function sendTemplate($to, $templateName, $languageCode = 'es_CO')
    {
        $phoneNumberId = config('services.whatsapp.phone_number_id');
        $accessToken = config('services.whatsapp.access_token');

        if (empty($phoneNumberId) || empty($accessToken)) {
            Log::error('âŒ ConfiguraciÃ³n de WhatsApp incompleta para sendTemplate');
            return false;
        }

        $url = "https://graph.facebook.com/v17.0/{$phoneNumberId}/messages";

        $body = [
            'messaging_product' => 'whatsapp',
            'to' => $to,
            'type' => 'template',
            'template' => [
                'name' => $templateName,
                'language' => ['code' => $languageCode]
            ]
        ];

        try {
            $response = Http::withToken($accessToken)
                ->timeout(15)
                ->post($url, $body);

            Log::info("ğŸ“¡ sendTemplate status: " . $response->status());
            Log::info("ğŸ“¡ sendTemplate body:", $response->json());

            if ($response->successful()) {
                // marcar last interaction
                $this->setLastInteraction($to, now());

                // Guardar outbound en BD si tienes WhatsappMessage
                try {
                    if (class_exists(WhatsappMessage::class)) {
                        $respJson = $response->json();
                        $outMsgId = $respJson['messages'][0]['id'] ?? null;
                        WhatsappMessage::create([
                            'message_id' => $outMsgId,
                            'from_number' => $phoneNumberId,
                            'to_phone_number_id' => $to,
                            'direction' => 'outbound',
                            'message' => '[template] ' . $templateName,
                            'payload' => json_encode($respJson)
                        ]);
                    }
                } catch (\Throwable $e) {
                    Log::warning("No se pudo guardar outbound template: " . $e->getMessage());
                }

                return true;
            } else {
                Log::error("âŒ sendTemplate failed: " . $response->body());
                return false;
            }
        } catch (\Exception $e) {
            Log::error("ğŸ’¥ ExcepciÃ³n en sendTemplate: " . $e->getMessage());
            return false;
        }
    }

    // Manejo de estado del usuario (usando cache)
    private function getUserState($userPhone)
    {
        $state = cache("whatsapp_state_{$userPhone}") ?? [];
        Log::info("ğŸ“ Obteniendo estado del usuario {$userPhone}:", $state);
        return $state;
    }

    private function updateUserState($userPhone, $state)
    {
        Log::info("ğŸ“ Actualizando estado del usuario {$userPhone}:", $state);
        cache(["whatsapp_state_{$userPhone}" => array_merge($this->getUserState($userPhone), $state)]);
        Log::info("âœ… Estado actualizado");
    }

    private function clearUserState($userPhone)
    {
        Log::info("ğŸ§¹ Limpiando estado del usuario {$userPhone}");
        cache()->forget("whatsapp_state_{$userPhone}");
        Log::info("âœ… Estado limpiado");
    }
    
}
